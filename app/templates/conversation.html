{% extends "base.html" %}

{% block title %}Chat - {{ agent_name }} - Serendipity{% endblock %}

{% block content %}
<div class="flex h-full">
    <!-- Main Conversation Area -->
    <div class="flex-1 flex flex-col h-full min-w-0">
        <!-- Header -->
        <div class="bg-slate-800 border-b border-slate-700 px-4 py-3">
            <div class="flex items-center justify-between ml-10 lg:ml-0">
                <div class="flex items-center gap-3">
                    <a href="/agent/{{ agent_name }}/conversations" class="text-slate-400 hover:text-white hidden lg:block">
                        <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"/>
                        </svg>
                    </a>
                    <h1 id="conversation-title" class="text-lg font-semibold truncate">New Conversation</h1>
                </div>
                <div class="flex items-center gap-2">
                    <button onclick="refreshConversation()" class="p-2 text-slate-400 hover:text-white rounded-lg hover:bg-slate-700" title="Refresh">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                        </svg>
                    </button>
                    <button onclick="toggleConversationMenu()" class="p-2 text-slate-400 hover:text-white rounded-lg hover:bg-slate-700" title="Conversation Actions">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 6h16M4 12h16M4 18h16"/>
                        </svg>
                    </button>
                    <button onclick="toggleSettingsPanel()" class="p-2 text-slate-400 hover:text-white rounded-lg hover:bg-slate-700 lg:hidden" title="Settings">
                        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                        </svg>
                    </button>
                </div>
            </div>
            
            <!-- Context size indicator -->
            <div class="mt-2">
                <div class="flex items-center justify-between text-xs text-slate-400 mb-1">
                    <span>Context</span>
                    <span><span id="context-info">0 / 4096 tokens</span> ¬∑ <span id="context-cost">$0.0000</span></span>
                </div>
                <div class="context-progress">
                    <div id="context-bar" class="context-progress-bar" style="width: 0%"></div>
                </div>
            </div>
        </div>
    
    <!-- Messages Area -->
    <div id="messages-container" class="flex-1 overflow-y-auto p-4 space-y-4">
        <div id="messages-loading" class="flex justify-center py-12">
            <div class="spinner"></div>
        </div>
        
        <div id="messages-list" class="hidden">
            <!-- Messages will be inserted here -->
        </div>
        
        <div id="no-messages" class="text-center py-12 hidden">
            <svg class="w-16 h-16 mx-auto text-slate-600 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8 12h.01M12 12h.01M16 12h.01M21 12c0 4.418-4.03 8-9 8a9.863 9.863 0 01-4.255-.949L3 20l1.395-3.72C3.512 15.042 3 13.574 3 12c0-4.418 4.03-8 9-8s9 3.582 9 8z"/>
            </svg>
            <p class="text-slate-400">Start the conversation by sending a message</p>
        </div>
        
        <!-- Streaming message with typing indicator (unified element) -->
        <div id="streaming-message" class="message-card assistant-message hidden">
            <div class="message-avatar" id="streaming-avatar">AI</div>
            <div class="message-bubble">
                <div class="sender" id="streaming-sender"></div>
                <div class="content" id="streaming-content">
                    <!-- Typing dots shown initially, replaced by content when streaming -->
                    <div id="typing-dots" class="typing-dots">
                        <span></span>
                        <span></span>
                        <span></span>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Input Area -->
    <div class="chat-input-area">
        <!-- Staged files -->
        <div id="staged-files" class="hidden mb-3">
            <div class="flex flex-wrap gap-2" id="staged-files-list"></div>
        </div>
        
        <input type="file" id="file-input" class="hidden" multiple onchange="handleFileSelect(event)">
        
        <!-- Top row: Sending as + Respond as + Run (on mobile these stack) -->
        <div class="flex flex-wrap items-center gap-3 mb-3">
            <div class="flex items-center gap-2">
                <span class="text-xs text-slate-400">Sending as:</span>
                <input type="text" id="sender-name" value="User" 
                       class="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm w-24">
            </div>
            <div class="flex items-center gap-2">
                <span class="text-xs text-slate-400">Respond as:</span>
                <select id="respond-as" class="bg-slate-700 border border-slate-600 rounded px-2 py-1 text-sm">
                    <option value="{{ agent_name }}">{{ agent_name }}</option>
                </select>
            </div>
            <label class="flex items-center gap-2 cursor-pointer">
                <input type="checkbox" id="run-toggle" checked class="w-4 h-4 rounded">
                <span class="text-xs text-slate-400">Run</span>
            </label>
        </div>
        
        <!-- Bottom row: Message input with buttons -->
        <div class="flex items-end gap-2">
            <!-- File upload button -->
            <button onclick="document.getElementById('file-input').click()" class="p-2 text-slate-400 hover:text-white rounded-lg hover:bg-slate-700 flex-shrink-0" title="Attach file">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15.172 7l-6.586 6.586a2 2 0 102.828 2.828l6.414-6.586a4 4 0 00-5.656-5.656l-6.415 6.585a6 6 0 108.486 8.486L20.5 13"/>
                </svg>
            </button>
            
            <!-- Message textarea - takes full remaining width -->
            <textarea id="message-input" rows="1" placeholder="Type your message..."
                      class="flex-1 bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 resize-none min-w-0"></textarea>
            
            <!-- Mic button -->
            <button id="mic-btn" onclick="toggleRecording()" class="p-2 bg-slate-700 border border-slate-600 rounded-lg hover:bg-slate-600 transition-colors flex-shrink-0" title="Record voice">
                <svg id="mic-icon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z"/>
                </svg>
                <svg id="mic-recording-icon" class="w-5 h-5 text-red-500 hidden animate-pulse" fill="currentColor" viewBox="0 0 24 24">
                    <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
                    <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
                </svg>
            </button>
            
            <!-- Send button -->
            <button onclick="sendMessage()" id="send-btn" class="btn-primary p-2 w-10 h-10 flex items-center justify-center flex-shrink-0">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"/>
                </svg>
            </button>
            
            <!-- Stop generating button (hidden by default) -->
            <button onclick="stopGenerating()" id="stop-btn" class="hidden p-2 w-10 h-10 flex items-center justify-center rounded-lg transition-colors flex-shrink-0" style="background-color: #dc2626;" title="Stop generating">
                <svg class="w-5 h-5" fill="white" viewBox="0 0 24 24">
                    <rect x="5" y="5" width="14" height="14" rx="2"/>
                </svg>
            </button>
        </div>
    </div>
    </div>

    <!-- Settings Panel (responsive sidebar) -->
    <div id="settings-panel" class="settings-panel-desktop w-80 bg-slate-800 border-l border-slate-700 overflow-y-auto flex-shrink-0">
        <div class="p-4">
            <div class="flex items-center justify-between mb-4">
                <h2 class="text-lg font-semibold">Settings</h2>
                <button onclick="toggleSettingsPanel()" class="lg:hidden text-slate-400 hover:text-white">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                    </svg>
                </button>
            </div>
        
        <!-- Model selector -->
        <div class="mb-4">
            <label class="text-sm text-slate-400 block mb-2">Model</label>
            <select id="model-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2">
                <option>Loading...</option>
            </select>
        </div>
        
        <!-- Temperature -->
        <div class="mb-4">
            <label class="text-sm text-slate-400 block mb-2">Temperature: <span id="temp-value">0.7</span></label>
            <input type="range" id="temperature" min="0" max="2" step="0.1" value="0.7" 
                   class="w-full" oninput="document.getElementById('temp-value').textContent = this.value">
        </div>
        
        <!-- Memory -->
        <div class="mb-4">
            <label class="text-sm text-slate-400 block mb-2">Memory: <span id="memory-value">0</span></label>
            <input type="range" id="memory" min="0" max="100" step="1" value="0" 
                   class="w-full" oninput="document.getElementById('memory-value').textContent = this.value">
        </div>
        
        <!-- Tools -->
        <div class="mb-4">
            <label class="text-sm text-slate-400 block mb-2">Tools</label>
            <div id="tools-list" class="space-y-2">
                <span class="text-slate-500 text-sm">Loading...</span>
            </div>
        </div>
        
        <!-- Roles -->
        <div class="mb-4">
            <label class="text-sm text-slate-400 block mb-2">Roles</label>
            <div id="roles-list" class="space-y-2">
                <span class="text-slate-500 text-sm">Loading...</span>
            </div>
        </div>
        
        <!-- System Message (Collapsible) -->
        <div class="border-t border-slate-700 pt-4 mt-4">
            <button onclick="togglePanel('system-message-panel')" class="flex items-center justify-between w-full text-left">
                <h3 class="text-sm font-medium text-slate-300">System Message</h3>
                <svg id="system-message-panel-icon" class="w-4 h-4 text-slate-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
            <div id="system-message-panel" class="hidden mt-3">
                <textarea id="system-message-edit" rows="6" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-3 py-2 text-sm font-mono" placeholder="System message..."></textarea>
                <button onclick="saveSystemMessage()" class="btn-secondary w-full mt-2 text-sm">Save System Message</button>
            </div>
        </div>
        
        <!-- Todo List (Collapsible) -->
        <div class="border-t border-slate-700 pt-4 mt-4">
            <button onclick="togglePanel('todo-panel')" class="flex items-center justify-between w-full text-left">
                <h3 class="text-sm font-medium text-slate-300">üìã Todo List</h3>
                <svg id="todo-panel-icon" class="w-4 h-4 text-slate-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
            <div id="todo-panel" class="hidden mt-3">
                <div id="todo-list" class="space-y-2 max-h-48 overflow-y-auto">
                    <span class="text-slate-500 text-sm">Click to load...</span>
                </div>
                <button onclick="loadTodoList()" class="text-xs text-indigo-400 hover:text-indigo-300 mt-2">Refresh</button>
            </div>
        </div>
        
        <!-- Wishlist (Collapsible) -->
        <div class="border-t border-slate-700 pt-4 mt-4">
            <button onclick="togglePanel('wishlist-panel')" class="flex items-center justify-between w-full text-left">
                <h3 class="text-sm font-medium text-slate-300">‚≠ê Wishlist</h3>
                <svg id="wishlist-panel-icon" class="w-4 h-4 text-slate-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
            <div id="wishlist-panel" class="hidden mt-3">
                <div id="wishlist-list" class="space-y-2 max-h-48 overflow-y-auto">
                    <span class="text-slate-500 text-sm">Click to load...</span>
                </div>
                <button onclick="loadWishlist()" class="text-xs text-indigo-400 hover:text-indigo-300 mt-2">Refresh</button>
            </div>
        </div>
        
        <!-- Variables (Collapsible) -->
        <div class="border-t border-slate-700 pt-4 mt-4">
            <button onclick="togglePanel('variables-panel')" class="flex items-center justify-between w-full text-left">
                <h3 class="text-sm font-medium text-slate-300">üîß Variables</h3>
                <svg id="variables-panel-icon" class="w-4 h-4 text-slate-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
            <div id="variables-panel" class="hidden mt-3">
                <div id="variables-list" class="space-y-2 max-h-48 overflow-y-auto font-mono text-xs">
                    <span class="text-slate-500 text-sm">Click to load...</span>
                </div>
                <button onclick="loadVariables()" class="text-xs text-indigo-400 hover:text-indigo-300 mt-2">Refresh</button>
            </div>
        </div>
        
        <!-- Workspace (Collapsible) -->
        <div class="border-t border-slate-700 pt-4 mt-4">
            <button onclick="togglePanel('workspace-panel')" class="flex items-center justify-between w-full text-left">
                <h3 class="text-sm font-medium text-slate-300">üìÅ Workspace</h3>
                <svg id="workspace-panel-icon" class="w-4 h-4 text-slate-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
            <div id="workspace-panel" class="hidden mt-3">
                <div id="workspace-tree" class="max-h-64 overflow-y-auto text-sm">
                    <span class="text-slate-500 text-sm">Click to load...</span>
                </div>
                <button onclick="loadWorkspace()" class="text-xs text-indigo-400 hover:text-indigo-300 mt-2">Refresh</button>
            </div>
        </div>
        
        <!-- Open Files (Collapsible) -->
        <div class="border-t border-slate-700 pt-4 mt-4">
            <button onclick="togglePanel('open-files-panel')" class="flex items-center justify-between w-full text-left">
                <h3 class="text-sm font-medium text-slate-300">üìÑ Open Files</h3>
                <svg id="open-files-panel-icon" class="w-4 h-4 text-slate-400 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"/>
                </svg>
            </button>
            <div id="open-files-panel" class="hidden mt-3">
                <div id="open-files-list" class="space-y-2 max-h-48 overflow-y-auto">
                    <span class="text-slate-500 text-sm">No files in context</span>
                </div>
            </div>
        </div>
    </div>
</div>
</div>

<!-- Conversation Manager Dialog -->
<div id="conversation-menu" class="modal-backdrop hidden">
    <div class="modal-content max-w-sm">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-bold">Conversation Actions</h2>
            <button onclick="toggleConversationMenu()" class="text-slate-400 hover:text-white p-1 rounded hover:bg-slate-700">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <!-- New Conversation -->
        <button onclick="startNewConversation()" class="w-full flex items-center gap-3 p-3 mb-4 bg-green-600/20 hover:bg-green-600/30 border border-green-600/30 rounded-lg transition-colors text-green-400">
            <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 4v16m8-8H4"/>
            </svg>
            <span class="font-medium">New Conversation</span>
        </button>
        
        <!-- AI Actions Group -->
        <div class="mb-4">
            <p class="text-xs text-slate-500 uppercase tracking-wider mb-2 px-1">AI Actions</p>
            <div class="space-y-1 bg-slate-800/50 rounded-lg p-2">
                <button onclick="summarizeCurrentConversation()" class="w-full flex items-center gap-3 p-2.5 hover:bg-slate-700 rounded-lg transition-colors">
                    <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
                    </svg>
                    <span>Summarize Conversation</span>
                </button>
                
                <button onclick="generateMemoryFromConversation()" class="w-full flex items-center gap-3 p-2.5 hover:bg-slate-700 rounded-lg transition-colors">
                    <svg class="w-5 h-5 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                    </svg>
                    <span>Generate Memory</span>
                </button>
                
                <button onclick="updateKnowledgeBaseFromConversation()" class="w-full flex items-center gap-3 p-2.5 hover:bg-slate-700 rounded-lg transition-colors">
                    <svg class="w-5 h-5 text-cyan-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253"/>
                    </svg>
                    <span>Update Knowledge Base</span>
                </button>
            </div>
        </div>
        
        <!-- Organization Group -->
        <div class="mb-4">
            <p class="text-xs text-slate-500 uppercase tracking-wider mb-2 px-1">Organization</p>
            <div class="space-y-1 bg-slate-800/50 rounded-lg p-2">
                <button onclick="showMoveToFolderDialog()" class="w-full flex items-center gap-3 p-2.5 hover:bg-slate-700 rounded-lg transition-colors">
                    <svg class="w-5 h-5 text-orange-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3 7v10a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-6l-2-2H5a2 2 0 00-2 2z"/>
                    </svg>
                    <span>Move to Folder</span>
                </button>
                
                <button onclick="archiveCurrentConversation()" class="w-full flex items-center gap-3 p-2.5 hover:bg-slate-700 rounded-lg transition-colors">
                    <svg class="w-5 h-5 text-yellow-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 8h14M5 8a2 2 0 110-4h14a2 2 0 110 4M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8m-9 4h4"/>
                    </svg>
                    <span>Archive Conversation</span>
                </button>
            </div>
        </div>
        
        <!-- Danger Zone -->
        <div>
            <p class="text-xs text-slate-500 uppercase tracking-wider mb-2 px-1">Danger Zone</p>
            <button onclick="deleteCurrentConversation()" class="w-full flex items-center gap-3 p-2.5 bg-red-600/10 hover:bg-red-600/20 border border-red-600/20 rounded-lg transition-colors text-red-400">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                <span>Delete Conversation</span>
            </button>
        </div>
    </div>
</div>

<!-- Message Actions Dialog -->
<div id="message-actions-dialog" class="modal-backdrop hidden">
    <div class="modal-content max-w-sm">
        <div class="flex items-center justify-between mb-4">
            <h2 class="text-xl font-bold">Message Actions</h2>
            <button onclick="closeMessageActionsDialog()" class="text-slate-400 hover:text-white p-1 rounded hover:bg-slate-700">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <!-- Message Preview -->
        <div id="message-preview" class="mb-4 p-3 bg-slate-800/50 rounded-lg text-sm text-slate-400 max-h-20 overflow-hidden">
            <span id="message-preview-sender" class="font-medium text-slate-300"></span>: <span id="message-preview-content"></span>
        </div>
        
        <!-- Actions -->
        <div class="space-y-2">
            <button onclick="continueMessage()" class="w-full flex items-center gap-3 p-3 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                <svg class="w-5 h-5 text-green-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14 5l7 7m0 0l-7 7m7-7H3"/>
                </svg>
                <div class="text-left">
                    <div class="font-medium">Continue</div>
                    <div class="text-xs text-slate-400">Continue generating from this message</div>
                </div>
            </button>
            
            <button onclick="regenerateMessage()" class="w-full flex items-center gap-3 p-3 bg-slate-700 hover:bg-slate-600 rounded-lg transition-colors">
                <svg class="w-5 h-5 text-blue-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"/>
                </svg>
                <div class="text-left">
                    <div class="font-medium">Regenerate</div>
                    <div class="text-xs text-slate-400">Delete and regenerate this response</div>
                </div>
            </button>
            
            <button onclick="deleteMessage()" class="w-full flex items-center gap-3 p-3 bg-red-600/10 hover:bg-red-600/20 border border-red-600/20 rounded-lg transition-colors text-red-400">
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"/>
                </svg>
                <div class="text-left">
                    <div class="font-medium">Delete</div>
                    <div class="text-xs text-red-400/70">Delete this and all following messages</div>
                </div>
            </button>
        </div>
    </div>
</div>

<!-- Move to Folder Dialog -->
<div id="move-folder-dialog" class="modal-backdrop hidden">
    <div class="modal-content max-w-sm">
        <div class="flex items-center justify-between mb-6">
            <h2 class="text-xl font-bold">Move to Folder</h2>
            <button onclick="closeMoveToFolderDialog()" class="text-slate-400 hover:text-white">
                <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                </svg>
            </button>
        </div>
        
        <div class="space-y-4">
            <div>
                <label class="text-sm text-slate-400 block mb-2">Select Folder</label>
                <select id="move-folder-select" class="w-full bg-slate-700 border border-slate-600 rounded-lg px-4 py-2">
                    <option value="">Loading folders...</option>
                </select>
            </div>
            
            <div class="flex gap-3">
                <button onclick="moveConversationToFolder()" class="btn-primary flex-1">Move</button>
                <button onclick="closeMoveToFolderDialog()" class="btn-secondary">Cancel</button>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script type="module">
    import { getConversation, getAgent, getModels, addMessage, getSettings, saveSettings, uploadFile, stageFile, removeStagedFile, createStreamingConnection, archiveConversation, deleteConversation, summarizeConversation, generateMemory, updateKnowledgeBase, moveToFolder, getFolders, editConversation, getAvailableVoices, getTTSUrl, transcribeAudio, getTodo, getWishlist, getVariables, getWorkspace, stopGeneration } from '/static/js/api.js';
    import { signData } from '/static/js/bitcoin.js';
    
    const agentName = '{{ agent_name }}';
    const urlParams = new URLSearchParams(window.location.search);
    let conversationId = urlParams.get('conversation_id') || '';
    let conversationData = null;
    let stagedFiles = [];
    let ws = null;
    
    let agentData = null;
    let selectedMessageId = null;
    let selectedMessageSender = null;
    let selectedMessageContent = null;
    
    // TTS state
    let availableVoices = [];
    let currentAudio = null;
    let playingMessageId = null;
    let playedAudioMessages = new Set();
    let audioUnlocked = false;
    
    // Unlock audio playback on first user interaction (needed for Firefox)
    function unlockAudio() {
        if (audioUnlocked) return;
        
        // Create and play a silent audio to unlock autoplay
        const silentAudio = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
        silentAudio.volume = 0;
        silentAudio.play().then(() => {
            audioUnlocked = true;
            console.log('Audio playback unlocked');
        }).catch(() => {
            // Ignore errors - will try again on next interaction
        });
    }
    
    // Add unlock listeners for various user interactions
    ['click', 'touchstart', 'keydown'].forEach(event => {
        document.addEventListener(event, unlockAudio, { once: false, passive: true });
    });
    
    // Voice recording state
    let mediaRecorder = null;
    let audioChunks = [];
    let isRecording = false;
    
    // Wait for WIF key to be available (set by base template)
    async function waitForWifKey(maxWaitMs = 5000) {
        const startTime = Date.now();
        while (!window.currentWif && (Date.now() - startTime) < maxWaitMs) {
            await new Promise(resolve => setTimeout(resolve, 100));
        }
        if (!window.currentWif) {
            console.log('WIF key not available after waiting');
        }
        return !!window.currentWif;
    }
    
    document.addEventListener('DOMContentLoaded', async () => {
        // Wait for base template to initialize (sets window.currentWif)
        await waitForWifKey();
        
        // Load agent data first to get default model
        await loadAgentData();
        await loadModels();
        await loadAvailableVoices();
        
        if (conversationId) {
            await loadConversation();
        } else {
            document.getElementById('messages-loading').classList.add('hidden');
            document.getElementById('no-messages').classList.remove('hidden');
            // For new conversations, set agent's default settings
            if (agentData?.agent?.model_name) {
                document.getElementById('model-select').value = agentData.agent.model_name;
            }
            if (agentData?.agent?.temperature !== undefined) {
                document.getElementById('temperature').value = agentData.agent.temperature;
                document.getElementById('temp-value').textContent = agentData.agent.temperature;
            }
            if (agentData?.agent?.memory !== undefined) {
                document.getElementById('memory').value = agentData.agent.memory;
                document.getElementById('memory-value').textContent = agentData.agent.memory;
            }
            
            // Initialize new conversation with info message (like Flutter app does)
            await initializeNewConversation();
        }
        
        // Auto-resize textarea
        const textarea = document.getElementById('message-input');
        textarea.addEventListener('input', () => {
            textarea.style.height = 'auto';
            textarea.style.height = Math.min(textarea.scrollHeight, 200) + 'px';
        });
        
        updateSidebarAgentInfo();
    });
    
    async function loadAgentData() {
        try {
            agentData = await getAgent(agentName);
            
            // Update sender name from agent's user_name
            if (agentData?.agent?.user_name) {
                document.getElementById('sender-name').value = agentData.agent.user_name;
            }
            
            // Update respond-as options for new conversations
            const respondAs = document.getElementById('respond-as');
            if (agentData?.agent?.participants) {
                respondAs.innerHTML = '';
                agentData.agent.participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p;
                    option.textContent = p;
                    respondAs.appendChild(option);
                });
            }
            
            // For new conversations, select first speaker from order_of_speakers
            updateNextSpeaker(0);
        } catch (e) {
            console.error('Failed to load agent data:', e);
        }
    }
    
    function updateNextSpeaker(messageCount) {
        const orderOfSpeakers = agentData?.agent?.order_of_speakers || [];
        if (orderOfSpeakers.length === 0) return;
        
        const nextSpeakerIndex = messageCount % orderOfSpeakers.length;
        const nextSpeaker = orderOfSpeakers[nextSpeakerIndex];
        
        const respondAs = document.getElementById('respond-as');
        if (respondAs && nextSpeaker) {
            respondAs.value = nextSpeaker;
        }
    }
    
    async function loadAvailableVoices() {
        try {
            const data = await getAvailableVoices(agentName);
            availableVoices = data.voices || [];
        } catch (e) {
            // Voice loading is optional - TTS uses sender name as voice
            console.debug('Voice loading skipped:', e.message);
        }
    }
    
    // TTS playback functions
    function getTextOnlyContent(content) {
        // Strip HTML tags and get plain text for TTS
        const div = document.createElement('div');
        div.innerHTML = content;
        // Remove thinking blocks
        div.querySelectorAll('.thinking-block').forEach(el => el.remove());
        return div.textContent || div.innerText || '';
    }
    
    // Get the voice for a specific sender - voice name = sender name
    function getVoiceForSender(sender) {
        // The voice name is simply the sender name
        // InitializeAgentVoices creates a voice file for each character with their name
        return sender;
    }
    
    window.playMessageAudio = function(messageId, sender, content) {
        const settings = getSettings();
        const openvoiceServer = settings.openvoiceServer;
        
        if (!openvoiceServer) {
            showToast('Please configure Voice Server in Settings', 'error');
            return;
        }
        
        // Auto-select voice based on sender
        const voice = getVoiceForSender(sender);
        
        if (!voice) {
            showToast('No voice configured for ' + sender, 'error');
            return;
        }
        
        // Get plain text content
        const textContent = getTextOnlyContent(content);
        if (!textContent.trim()) {
            showToast('No text content to play', 'error');
            return;
        }
        
        // Stop current audio if playing
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
            updatePlayButtonState(playingMessageId, false);
        }
        
        // If clicking on same message that was playing, just stop
        if (playingMessageId === messageId) {
            playingMessageId = null;
            return;
        }
        
        // Generate TTS URL and play
        const ttsUrl = getTTSUrl(openvoiceServer, textContent, voice);
        console.log('TTS URL:', ttsUrl);
        console.log('Voice:', voice, 'Sender:', sender);
        
        if (!ttsUrl) {
            showToast('Failed to generate TTS URL', 'error');
            return;
        }
        
        playingMessageId = messageId;
        updatePlayButtonState(messageId, true);
        
        currentAudio = new Audio(ttsUrl);
        
        // Add canplaythrough event to ensure audio is ready
        currentAudio.addEventListener('canplaythrough', () => {
            console.log('Audio ready to play');
        });
        
        currentAudio.play().catch(e => {
            console.error('Failed to play audio:', e);
            console.error('TTS URL was:', ttsUrl);
            showToast('Failed to play audio: ' + e.message, 'error');
            playingMessageId = null;
            updatePlayButtonState(messageId, false);
        });
        
        currentAudio.onended = () => {
            playingMessageId = null;
            updatePlayButtonState(messageId, false);
            playedAudioMessages.add(messageId);
        };
        
        currentAudio.onerror = () => {
            showToast('Audio playback error', 'error');
            playingMessageId = null;
            updatePlayButtonState(messageId, false);
        };
    };
    
    window.stopMessageAudio = function() {
        if (currentAudio) {
            currentAudio.pause();
            currentAudio = null;
            if (playingMessageId) {
                updatePlayButtonState(playingMessageId, false);
                playingMessageId = null;
            }
        }
    };
    
    function updatePlayButtonState(messageId, isPlaying) {
        const messageCard = document.querySelector(`[data-message-id="${messageId}"]`);
        const btn = messageCard?.querySelector('.play-audio-btn');
        
        if (messageCard) {
            if (isPlaying) {
                messageCard.classList.add('audio-playing');
                // Add click handler to stop audio
                messageCard.onclick = (e) => {
                    if (!e.target.closest('.play-audio-btn')) {
                        stopMessageAudio();
                    }
                };
            } else {
                messageCard.classList.remove('audio-playing');
                messageCard.onclick = null;
            }
        }
        
        if (btn) {
            const icon = btn.querySelector('svg');
            if (isPlaying) {
                btn.classList.add('text-indigo-400');
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z"/>';
            } else {
                btn.classList.remove('text-indigo-400');
                icon.innerHTML = '<path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>';
            }
        }
    }
    
    function autoPlayLastMessage(messageId, sender, content) {
        const settings = getSettings();
        if (!settings.autoPlayVoice || !settings.activeVoice || !settings.openvoiceServer) return;
        if (playedAudioMessages.has(messageId)) return;
        
        // Auto-play any message type
        playMessageAudio(messageId, sender, content);
    }
    
    async function initializeNewConversation() {
        if (!window.currentWif) {
            console.log('No WIF key, skipping conversation initialization');
            return;
        }
        
        const settings = getSettings();
        const model = document.getElementById('model-select').value;
        const temperature = parseFloat(document.getElementById('temperature').value);
        
        // Create initial info message with current datetime (like Flutter app)
        const messageData = {
            conversation_id: '',
            sender: agentName,
            respond_as: agentName,
            content: '',
            agent: agentName,
            folder_name: settings.folderName,
            enabled_tools: [],
            enabled_roles: [],
            memory: agentData?.agent?.memory || 0,
            temperature: temperature,
            model_name: model,
            run: false,
            files: []
        };
        
        try {
            console.log('Initializing new conversation', messageData);
            const response = await addMessage(window.currentWif, messageData);
            console.log('AddMessage response:', response);
            
            // Response might have conversation_id in different places
            const convId = response.conversation_id || response.conversation?.conversation_id;
            if (convId) {
                conversationId = convId;
                window.history.replaceState({}, '', `/agent/${encodeURIComponent(agentName)}/conversation?conversation_id=${encodeURIComponent(conversationId)}`);
                
                // Connect WebSocket for this conversation
                connectWebSocket();
                
                // Load the conversation to show any server-added messages
                await loadConversation();
                
                console.log('New conversation initialized:', conversationId);
            } else {
                console.error('No conversation_id in response:', response);
            }
        } catch (e) {
            console.error('Failed to initialize conversation:', e);
        }
    }
    
    let modelContextSizes = {};
    let currentTokenCount = 0;
    
    async function loadModels() {
        try {
            const data = await getModels();
            const select = document.getElementById('model-select');
            select.innerHTML = '';
            
            // Store model context sizes for later use
            if (data.model_context_sizes) {
                modelContextSizes = data.model_context_sizes;
            }
            
            if (data.model_names) {
                data.model_names.forEach(model => {
                    const option = document.createElement('option');
                    option.value = model;
                    option.textContent = model;
                    if (model === data.default_model) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
            }
            
            // Add change listener to update context size when model changes
            select.addEventListener('change', updateContextDisplay);
        } catch (e) {
            console.error('Failed to load models:', e);
        }
    }
    
    function updateContextDisplay(newTokenCount = null) {
        if (newTokenCount !== null) {
            currentTokenCount = newTokenCount;
        }
        const model = document.getElementById('model-select').value;
        const contextSize = modelContextSizes[model] || 4096;
        
        document.getElementById('context-info').textContent = `${currentTokenCount} / ${contextSize} tokens`;
        
        // Update progress bar
        const percentage = Math.min((currentTokenCount / contextSize) * 100, 100);
        document.getElementById('context-bar').style.width = `${percentage}%`;
    }
    
    window.loadConversation = async function() {
        if (!conversationId) return;
        
        const loading = document.getElementById('messages-loading');
        const list = document.getElementById('messages-list');
        const noMessages = document.getElementById('no-messages');
        const streamingEl = document.getElementById('streaming-message');
        
        // Hide streaming message when loading conversation
        streamingEl.classList.add('hidden');
        
        loading.classList.remove('hidden');
        list.classList.add('hidden');
        noMessages.classList.add('hidden');
        
        try {
            const settings = getSettings();
            const data = await getConversation(agentName, settings.folderName, conversationId);
            conversationData = data;
            
            // Update title
            document.getElementById('conversation-title').textContent = 
                data.conversation?.title || 'Conversation';
            
            // Update settings panel - set model first so context display uses correct context size
            if (data.conversation?.model_name) {
                document.getElementById('model-select').value = data.conversation.model_name;
            }
            
            // Update context info
            const currentTokens = data.conversation?.current_tokens || 0;
            const totalCost = data.conversation?.total_cost || 0;
            document.getElementById('context-cost').textContent = `$${totalCost.toFixed(4)}`;
            
            // Update context display with token count (will use model's context size)
            updateContextDisplay(currentTokens);
            if (data.conversation?.temperature !== undefined) {
                document.getElementById('temperature').value = data.conversation.temperature;
                document.getElementById('temp-value').textContent = data.conversation.temperature;
            }
            
            // Update respond-as options
            const respondAs = document.getElementById('respond-as');
            respondAs.innerHTML = '';
            if (data.conversation?.participants) {
                data.conversation.participants.forEach(p => {
                    const option = document.createElement('option');
                    option.value = p;
                    option.textContent = p;
                    respondAs.appendChild(option);
                });
            }
            
            // Auto-select next speaker based on order_of_speakers and message count
            const messageCount = data.conversation?.messages?.length || 0;
            updateNextSpeaker(messageCount);
            
            // Update tools list
            updateToolsList(data.conversation?.enabled_tools || []);
            
            // Update roles list
            updateRolesList(data.conversation?.enabled_roles || []);
            
            // Update staged files
            if (data.staged_files && data.staged_files.length > 0) {
                stagedFiles = data.staged_files;
                updateStagedFilesDisplay();
            }
            
            // Render messages
            renderMessages(data.conversation?.messages || []);
            
            loading.classList.add('hidden');
            
            if (data.conversation?.messages?.length > 0) {
                list.classList.remove('hidden');
                scrollToBottom();
            } else {
                noMessages.classList.remove('hidden');
            }
            
            // Connect to WebSocket for streaming
            connectWebSocket();
            
        } catch (e) {
            console.error('Failed to load conversation:', e);
            loading.classList.add('hidden');
            showToast('Failed to load conversation', 'error');
        }
    };
    
    window.refreshConversation = loadConversation;
    
    // Load conversation and trigger auto-play for the last message
    async function loadConversationWithAutoPlay() {
        if (!conversationId) return;
        
        const loading = document.getElementById('messages-loading');
        const list = document.getElementById('messages-list');
        const noMessages = document.getElementById('no-messages');
        const streamingEl = document.getElementById('streaming-message');
        
        streamingEl.classList.add('hidden');
        
        try {
            const settings = getSettings();
            const data = await getConversation(agentName, settings.folderName, conversationId);
            conversationData = data;
            
            // Update context info
            const currentTokens = data.conversation?.current_tokens || 0;
            const totalCost = data.conversation?.total_cost || 0;
            document.getElementById('context-cost').textContent = `$${totalCost.toFixed(4)}`;
            updateContextDisplay(currentTokens);
            
            // Update next speaker based on message count
            const messageCount = data.conversation?.messages?.length || 0;
            updateNextSpeaker(messageCount);
            
            // Render messages with auto-play enabled
            renderMessages(data.conversation?.messages || [], true);
            
            if (data.conversation?.messages?.length > 0) {
                list.classList.remove('hidden');
                scrollToBottom();
            }
            
        } catch (e) {
            console.error('Failed to load conversation:', e);
        }
    }
    
    function renderMessages(messages, triggerAutoPlay = false) {
        const list = document.getElementById('messages-list');
        list.innerHTML = '';
        
        messages.forEach((msg, index) => {
            const isLast = index === messages.length - 1;
            const messageEl = createMessageElement(msg, isLast);
            list.appendChild(messageEl);
            
            // Auto-play last message if enabled
            if (triggerAutoPlay && isLast && msg.message_id) {
                autoPlayLastMessage(msg.message_id, msg.sender, msg.content);
            }
        });
    }
    
    function createMessageElement(msg, isLast) {
        const div = document.createElement('div');
        div.dataset.messageId = msg.message_id || '';
        
        const sender = msg.sender || 'Unknown';
        const content = msg.content || '';
        
        // Determine message type for styling
        // Only the current user's messages go on the right, all others on the left
        const senderLower = sender.toLowerCase();
        const isInfo = senderLower === 'info';
        const userName = document.getElementById('sender-name')?.value || '';
        const isCurrentUser = !isInfo && senderLower === userName.toLowerCase();
        
        if (isInfo) {
            div.className = 'message-card info-message';
        } else if (isCurrentUser) {
            div.className = 'message-card user-message';
        } else {
            div.className = 'message-card assistant-message';
        }
        
        // Parse message parts if available
        let contentHtml = '';
        if (msg.parts && msg.parts.length > 0) {
            msg.parts.forEach(part => {
                contentHtml += renderMessagePart(part);
            });
        } else {
            // Process thinking tags in raw content too
            const processedContent = processThinkingTags(content);
            if (processedContent !== content) {
                const parts = processedContent.split(/(<div class="thinking-block[\s\S]*?<\/div>\s*<\/div>)/);
                contentHtml = `<div class="markdown-content">${parts.map(p => {
                    if (p.startsWith('<div class="thinking-block')) {
                        return p;
                    }
                    return marked.parse(p);
                }).join('')}</div>`;
            } else {
                contentHtml = `<div class="markdown-content">${marked.parse(content)}</div>`;
            }
        }
        
        // Render images if present
        if (msg.images && msg.images.length > 0) {
            const settings = getSettings();
            msg.images.forEach(img => {
                const imgUrl = `http://${settings.serverAddress}:${settings.serverPort}/spellbook/files/${img}`;
                contentHtml = `<img src="${imgUrl}" alt="Image" class="max-w-full rounded-lg mb-3">` + contentHtml;
            });
        }
        
        // Get avatar initials
        const initials = sender.substring(0, 2).toUpperCase();
        
        // Build chat bubble HTML
        if (isInfo) {
            div.innerHTML = `
                <div class="message-bubble">
                    <div class="flex items-center justify-between">
                        <div class="content flex-1">${escapeHtml(content)}</div>
                        <button class="play-audio-btn p-1 text-slate-400 hover:text-indigo-400 transition-colors ml-2" onclick="event.stopPropagation(); playMessageAudio('${msg.message_id || ''}', 'INFO', \`${escapeHtml(content).replace(/`/g, '\\`')}\`)" title="Play audio">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                        </button>
                    </div>
                </div>
            `;
        } else {
            div.innerHTML = `
                <div class="message-avatar">${initials}</div>
                <div class="message-bubble">
                    <div class="flex items-center justify-between">
                        <div class="sender">${escapeHtml(sender)}</div>
                        <button class="play-audio-btn p-1 text-slate-400 hover:text-indigo-400 transition-colors" onclick="event.stopPropagation(); playMessageAudio('${msg.message_id || ''}', '${escapeHtml(sender)}', \`${escapeHtml(content).replace(/`/g, '\\`')}\`)" title="Play audio">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M14.752 11.168l-3.197-2.132A1 1 0 0010 9.87v4.263a1 1 0 001.555.832l3.197-2.132a1 1 0 000-1.664z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z"/>
                            </svg>
                        </button>
                    </div>
                    <div class="content">${contentHtml}</div>
                </div>
            `;
        }
        
        // Highlight code blocks
        div.querySelectorAll('pre code').forEach(block => {
            hljs.highlightElement(block);
        });
        
        // Render mermaid diagrams
        div.querySelectorAll('.mermaid-diagram').forEach(async (el, idx) => {
            const code = el.dataset.code;
            const id = `mermaid-${Date.now()}-${idx}`;
            try {
                const { svg } = await mermaid.render(id, code);
                el.innerHTML = svg;
            } catch (e) {
                el.innerHTML = `<pre class="text-red-400">Mermaid error: ${e.message}</pre>`;
            }
        });
        
        // Add right-click and long-press handler for message actions (skip INFO messages)
        if (!isInfo && msg.message_id) {
            const messageId = msg.message_id;
            const msgSender = sender;
            const msgContent = content;
            
            // Right-click (desktop)
            div.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                openMessageActionsDialog(messageId, msgSender, msgContent);
            });
            
            // Long-press (mobile)
            let pressTimer;
            div.addEventListener('touchstart', (e) => {
                pressTimer = setTimeout(() => {
                    openMessageActionsDialog(messageId, msgSender, msgContent);
                }, 500);
            });
            div.addEventListener('touchend', () => clearTimeout(pressTimer));
            div.addEventListener('touchmove', () => clearTimeout(pressTimer));
            
            // Add cursor style to indicate interactivity
            div.style.cursor = 'context-menu';
        }
        
        return div;
    }
    
    // Process thinking tags - make them collapsible
    // isStreaming: if true, show thinking content expanded; if false, collapsed
    function processThinkingTags(content, isStreaming = false) {
        // Match <think>...</think> tags (case insensitive, multiline)
        const thinkRegex = /<think>([\s\S]*?)<\/think>/gi;
        
        return content.replace(thinkRegex, (match, thinkContent) => {
            const uniqueId = 'think-' + Math.random().toString(36).substr(2, 9);
            const isHidden = isStreaming ? '' : 'hidden';
            const isRotated = isStreaming ? 'rotate-90' : '';
            return `
                <div class="thinking-block mb-3">
                    <button onclick="toggleThinking('${uniqueId}')" class="flex items-center gap-2 text-sm text-slate-400 hover:text-slate-300 transition-colors">
                        <svg id="${uniqueId}-icon" class="w-4 h-4 transform transition-transform ${isRotated}" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"/>
                        </svg>
                        <span class="flex items-center gap-1.5">
                            <svg class="w-4 h-4 text-purple-400" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M21 12h-1M4 12H3m3.343-5.657l-.707-.707m2.828 9.9a5 5 0 117.072 0l-.548.547A3.374 3.374 0 0014 18.469V19a2 2 0 11-4 0v-.531c0-.895-.356-1.754-.988-2.386l-.548-.547z"/>
                            </svg>
                            Thinking...
                        </span>
                    </button>
                    <div id="${uniqueId}" class="thinking-content ${isHidden} mt-2 pl-6 border-l-2 border-purple-500/30 text-slate-400 text-sm italic">${escapeHtml(thinkContent.trim())}</div>
                </div>
            `;
        });
    }
    
    function renderMessagePart(part, isStreaming = false) {
        const type = part.type || 'text';
        const content = part.content || '';
        
        switch (type) {
            case 'text':
                // Process thinking tags before markdown parsing
                const processedContent = processThinkingTags(content, isStreaming);
                // Only parse markdown on non-thinking parts
                if (processedContent !== content) {
                    // Has thinking tags - parse the non-thinking parts
                    const parts = processedContent.split(/(<div class="thinking-block[\s\S]*?<\/div>\s*<\/div>)/);
                    return `<div class="markdown-content">${parts.map(p => {
                        if (p.startsWith('<div class="thinking-block')) {
                            return p; // Keep thinking blocks as-is
                        }
                        return marked.parse(p);
                    }).join('')}</div>`;
                }
                return `<div class="markdown-content">${marked.parse(content)}</div>`;
            
            case 'code':
                const lang = part.language || 'plaintext';
                return `
                    <div class="code-block-wrapper mb-3">
                        <div class="flex items-center justify-between bg-slate-700 px-3 py-1 rounded-t-md text-xs text-slate-400">
                            <span>${lang}</span>
                            <button onclick="copyCode(this)" class="hover:text-white">Copy</button>
                        </div>
                        <pre class="code-block !mt-0 !rounded-t-none"><code class="language-${lang}">${escapeHtml(content)}</code></pre>
                    </div>`;
            
            case 'mermaid':
                return `<div class="mermaid-diagram bg-slate-700 p-4 rounded-lg mb-3 overflow-x-auto" data-code="${escapeHtml(content)}"></div>`;
            
            case 'image':
                const settings = getSettings();
                const imgUrl = content.startsWith('http') ? content : `http://${settings.serverAddress}:${settings.serverPort}/spellbook/files/${content}`;
                return `<img src="${imgUrl}" alt="Image" class="max-w-full rounded-lg mb-3">`;
            
            case 'tool_request':
                const toolName = part.tool_name || part.name || 'Unknown tool';
                const toolArgs = part.arguments || part.args || {};
                return `
                    <div class="tool-request bg-slate-700 border-l-4 border-yellow-500 p-3 rounded-r-lg mb-3">
                        <div class="flex items-center gap-2 text-yellow-400 text-sm font-medium mb-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z"/>
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"/>
                            </svg>
                            Tool: ${escapeHtml(toolName)}
                        </div>
                        <pre class="text-xs text-slate-300 overflow-x-auto">${escapeHtml(JSON.stringify(toolArgs, null, 2))}</pre>
                    </div>`;
            
            case 'tool_response':
                const respToolName = part.tool_name || part.name || 'Unknown tool';
                return `
                    <div class="tool-response bg-slate-700 border-l-4 border-green-500 p-3 rounded-r-lg mb-3">
                        <div class="flex items-center gap-2 text-green-400 text-sm font-medium mb-2">
                            <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"/>
                            </svg>
                            Response: ${escapeHtml(respToolName)}
                        </div>
                        <pre class="text-xs text-slate-300 overflow-x-auto max-h-40">${escapeHtml(content)}</pre>
                    </div>`;
            
            default:
                return `<div class="markdown-content">${marked.parse(content)}</div>`;
        }
    }
    
    window.copyCode = function(btn) {
        const codeBlock = btn.closest('.code-block-wrapper').querySelector('code');
        navigator.clipboard.writeText(codeBlock.textContent);
        btn.textContent = 'Copied!';
        setTimeout(() => btn.textContent = 'Copy', 2000);
    };
    
    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // Track if user has manually scrolled up
    let userHasScrolledUp = false;
    
    // Listen for scroll events to detect manual scrolling
    document.getElementById('messages-container')?.addEventListener('scroll', () => {
        const container = document.getElementById('messages-container');
        if (container) {
            // Consider "near bottom" if within 150px of the bottom
            const isNearBottom = container.scrollHeight - container.scrollTop - container.clientHeight < 150;
            userHasScrolledUp = !isNearBottom;
        }
    });
    
    function scrollToBottom(force = false) {
        // Use setTimeout to ensure DOM has fully updated after content changes
        setTimeout(() => {
            const container = document.getElementById('messages-container');
            if (container) {
                // Only auto-scroll if user hasn't manually scrolled up, or if forced
                if (force || !userHasScrolledUp) {
                    container.scrollTop = container.scrollHeight + 1000;
                    userHasScrolledUp = false;
                }
            }
        }, 10);
    }
    
    window.sendMessage = async function() {
        const input = document.getElementById('message-input');
        const content = input.value.trim();
        
        // Allow empty messages - the agent can respond without user input
        
        if (!window.currentWif) {
            showToast('Please unlock your WIF key first', 'error');
            return;
        }
        
        const settings = getSettings();
        const sender = document.getElementById('sender-name').value || 'User';
        const respondAs = document.getElementById('respond-as').value || agentName;
        const run = document.getElementById('run-toggle').checked;
        const model = document.getElementById('model-select').value;
        const temperature = parseFloat(document.getElementById('temperature').value);
        const memory = parseInt(document.getElementById('memory').value);
        
        // Get enabled tools and roles
        const enabledTools = Array.from(document.querySelectorAll('#tools-list input:checked')).map(cb => cb.value);
        const enabledRoles = Array.from(document.querySelectorAll('#roles-list input:checked')).map(cb => cb.value);
        
        const messageData = {
            conversationId: conversationId,
            agent: agentName,
            folderName: settings.folderName,
            content: content,
            modelName: model,
            sender: sender,
            respondAs: respondAs,
            temperature: temperature,
            enabledRoles: enabledRoles,
            enabledTools: enabledTools,
            memory: memory,
            run: run,
            files: stagedFiles.map(f => f.fileName || f)
        };
        
        // Clear input
        input.value = '';
        input.style.height = 'auto';
        
        // Show user message immediately (only if there's content)
        const list = document.getElementById('messages-list');
        const noMessages = document.getElementById('no-messages');
        noMessages.classList.add('hidden');
        list.classList.remove('hidden');
        
        // Get current message count before adding
        const currentMessageCount = list.querySelectorAll('.message-card').length;
        
        if (content) {
            const userMsg = createMessageElement({ sender: sender, content: content }, false);
            list.appendChild(userMsg);
            scrollToBottom(true);  // Force scroll when user sends a message
        }
        
        // Update next speaker: +1 for user message, +1 more if AI will respond
        const newMessageCount = currentMessageCount + 1 + (run ? 1 : 0);
        updateNextSpeaker(newMessageCount);
        
        // Show streaming element with typing dots if we're expecting a response
        if (run) {
            const streamingEl = document.getElementById('streaming-message');
            const streamingSender = document.getElementById('streaming-sender');
            const streamingAvatar = document.getElementById('streaming-avatar');
            const streamingContent = document.getElementById('streaming-content');
            
            // Reset to typing dots state
            streamingSender.textContent = respondAs;
            streamingAvatar.textContent = respondAs.substring(0, 2).toUpperCase();
            // Reset content to typing dots
            streamingContent.innerHTML = `<div id="typing-dots" class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>`;
            
            // Update style based on sender
            const senderLower = respondAs.toLowerCase();
            const userName = document.getElementById('sender-name')?.value || '';
            const isCurrentUser = senderLower === userName.toLowerCase();
            streamingEl.className = isCurrentUser ? 'message-card user-message' : 'message-card assistant-message';
            
            streamingEl.classList.remove('hidden');
            setGeneratingState(true);
            scrollToBottom(true);  // Force scroll when starting AI response
        }
        
        // Connect to WebSocket if not already connected (for streaming)
        if (run && !ws) {
            connectWebSocket();
        }
        
        try {
            const response = await addMessage(window.currentWif, messageData);
            
            if (response.conversation_id) {
                const isNewConversation = !conversationId;
                conversationId = response.conversation_id;
                // Update URL without reload
                window.history.replaceState({}, '', `/agent/${encodeURIComponent(agentName)}/conversation?conversation_id=${encodeURIComponent(conversationId)}`);
                
                // Connect to WebSocket for streaming (especially important for new conversations)
                if (run && isNewConversation) {
                    connectWebSocket();
                }
            }
            
            // Clear staged files
            stagedFiles = [];
            updateStagedFilesDisplay();
            
            // If not running, refresh immediately. If running, WebSocket will trigger refresh on completion.
            if (!run) {
                setTimeout(() => {
                    loadConversation();
                }, 500);
            }
            
        } catch (e) {
            console.error('Failed to send message:', e);
            showToast('Failed to send message: ' + e.message, 'error');
            document.getElementById('streaming-message').classList.add('hidden');
            setGeneratingState(false);
        }
    };
    
    
    window.toggleSettings = function() {
        // For mobile: toggle the mobile settings panel
        const mobilePanel = document.getElementById('settings-panel-mobile');
        if (mobilePanel) {
            mobilePanel.classList.toggle('translate-x-full');
        }
    };
    
    let isGenerating = false;
    
    function setGeneratingState(generating) {
        isGenerating = generating;
        const sendBtn = document.getElementById('send-btn');
        const stopBtn = document.getElementById('stop-btn');
        
        if (generating) {
            sendBtn.classList.add('hidden');
            stopBtn.classList.remove('hidden');
        } else {
            sendBtn.classList.remove('hidden');
            stopBtn.classList.add('hidden');
        }
    }
    
    window.stopGenerating = async function() {
        if (!conversationId) return;
        
        try {
            const settings = getSettings();
            showToast('Stopping generation...', 'info');
            
            await stopGeneration(window.currentWif, {
                agent: agentName,
                conversationId: conversationId
            });
            
            // Hide streaming message
            document.getElementById('streaming-message').classList.add('hidden');
            
            setGeneratingState(false);
            
            // Reload conversation to get current state
            await loadConversation();
            
            showToast('Generation stopped', 'success');
        } catch (e) {
            console.error('Failed to stop generation:', e);
            showToast('Failed to stop generation: ' + e.message, 'error');
        }
    };
    
    window.toggleThinking = function(id) {
        const content = document.getElementById(id);
        const icon = document.getElementById(id + '-icon');
        if (content && icon) {
            content.classList.toggle('hidden');
            icon.classList.toggle('rotate-90');
        }
    };
    
    window.toggleConversationMenu = function() {
        const menu = document.getElementById('conversation-menu');
        menu.classList.toggle('hidden');
    };
    
    window.toggleSettingsPanel = function() {
        const panel = document.getElementById('settings-panel');
        panel.classList.toggle('settings-open');
    };
    
    // Close settings panel when clicking outside on mobile
    document.addEventListener('click', (e) => {
        const panel = document.getElementById('settings-panel');
        const settingsBtn = document.querySelector('[onclick="toggleSettingsPanel()"]');
        if (panel && panel.classList.contains('settings-open') && 
            !panel.contains(e.target) && 
            settingsBtn && !settingsBtn.contains(e.target)) {
            panel.classList.remove('settings-open');
        }
    });
    
    window.startNewConversation = function() {
        toggleConversationMenu();
        // Navigate to new conversation (no conversation_id)
        window.location.href = `/agent/${encodeURIComponent(agentName)}/conversation`;
    };
    
    window.archiveCurrentConversation = async function() {
        if (!conversationId) {
            showToast('No conversation to archive', 'error');
            return;
        }
        
        if (!confirm('Are you sure you want to archive this conversation?')) return;
        
        try {
            const settings = getSettings();
            await archiveConversation(window.currentWif, {
                agent: agentName,
                folder_name: settings.folderName,
                conversation_id: conversationId
            });
            showToast('Conversation archived', 'success');
            toggleConversationMenu();
            // Navigate back to conversations list
            window.location.href = `/agent/${encodeURIComponent(agentName)}/conversations`;
        } catch (e) {
            showToast('Failed to archive: ' + e.message, 'error');
        }
    };
    
    window.deleteCurrentConversation = async function() {
        if (!conversationId) {
            showToast('No conversation to delete', 'error');
            return;
        }
        
        if (!confirm('Are you sure you want to delete this conversation? This cannot be undone.')) return;
        
        try {
            const settings = getSettings();
            await deleteConversation(window.currentWif, {
                agent: agentName,
                folder_name: settings.folderName,
                conversation_id: conversationId
            });
            showToast('Conversation deleted', 'success');
            toggleConversationMenu();
            // Navigate back to conversations list
            window.location.href = `/agent/${encodeURIComponent(agentName)}/conversations`;
        } catch (e) {
            showToast('Failed to delete: ' + e.message, 'error');
        }
    };
    
    window.summarizeCurrentConversation = async function() {
        if (!conversationId) {
            showToast('No conversation to summarize', 'error');
            return;
        }
        
        try {
            const settings = getSettings();
            const model = document.getElementById('model-select').value;
            showToast('Summarizing conversation...', 'info');
            toggleConversationMenu();
            
            await summarizeConversation(window.currentWif, {
                agent: agentName,
                folder_name: settings.folderName,
                conversation_id: conversationId,
                model_name: model
            });
            showToast('Conversation summarized', 'success');
            await loadConversation();
        } catch (e) {
            showToast('Failed to summarize: ' + e.message, 'error');
        }
    };
    
    window.generateMemoryFromConversation = async function() {
        if (!conversationId) {
            showToast('No conversation to generate memory from', 'error');
            return;
        }
        
        try {
            const settings = getSettings();
            const model = document.getElementById('model-select').value;
            showToast('Generating memory...', 'info');
            toggleConversationMenu();
            
            await generateMemory(window.currentWif, {
                agent: agentName,
                folder_name: settings.folderName,
                conversation_id: conversationId,
                model_name: model
            });
            showToast('Memory generated', 'success');
        } catch (e) {
            showToast('Failed to generate memory: ' + e.message, 'error');
        }
    };
    
    window.updateKnowledgeBaseFromConversation = async function() {
        if (!conversationId) {
            showToast('No conversation to update knowledge base from', 'error');
            return;
        }
        
        try {
            const settings = getSettings();
            const model = document.getElementById('model-select').value;
            showToast('Updating knowledge base...', 'info');
            toggleConversationMenu();
            
            await updateKnowledgeBase(window.currentWif, {
                agent: agentName,
                folder_name: settings.folderName,
                conversation_id: conversationId,
                model_name: model
            });
            showToast('Knowledge base updated', 'success');
        } catch (e) {
            showToast('Failed to update knowledge base: ' + e.message, 'error');
        }
    };
    
    // Message Actions
    window.openMessageActionsDialog = function(messageId, sender, content) {
        console.log('Opening message actions for:', { messageId, sender, contentLength: content?.length });
        selectedMessageId = messageId;
        selectedMessageSender = sender;
        selectedMessageContent = content;
        
        // Update preview
        document.getElementById('message-preview-sender').textContent = sender;
        document.getElementById('message-preview-content').textContent = content.substring(0, 100) + (content.length > 100 ? '...' : '');
        
        document.getElementById('message-actions-dialog').classList.remove('hidden');
    };
    
    window.closeMessageActionsDialog = function() {
        document.getElementById('message-actions-dialog').classList.add('hidden');
        selectedMessageId = null;
        selectedMessageSender = null;
        selectedMessageContent = null;
    };
    
    window.continueMessage = async function() {
        if (!selectedMessageId) {
            showToast('No message selected', 'error');
            return;
        }
        
        try {
            const settings = getSettings();
            const model = document.getElementById('model-select').value;
            const temperature = parseFloat(document.getElementById('temperature').value);
            const messageIdToContinue = selectedMessageId;
            
            console.log('Continuing message:', { messageIdToContinue, conversationId, agentName });
            
            closeMessageActionsDialog();
            showToast('Continuing message...', 'info');
            
            // Show streaming element with typing dots
            const streamingEl = document.getElementById('streaming-message');
            const streamingContent = document.getElementById('streaming-content');
            streamingContent.innerHTML = `<div id="typing-dots" class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>`;
            streamingEl.className = 'message-card assistant-message';
            streamingEl.classList.remove('hidden');
            setGeneratingState(true);
            scrollToBottom(true);  // Force scroll when continuing
            
            await editConversation(window.currentWif, {
                conversation_id: conversationId,
                agent: agentName,
                folder_name: settings.folderName || '',
                message_id: messageIdToContinue,
                action: 'continue_message',
                model_name: model,
                temperature: temperature
            });
            
            // Connect WebSocket for streaming response
            connectWebSocket();
            
        } catch (e) {
            showToast('Failed to continue: ' + e.message, 'error');
            setGeneratingState(false);
            document.getElementById('streaming-message').classList.add('hidden');
        }
    };
    
    window.regenerateMessage = async function() {
        if (!selectedMessageId) {
            showToast('No message selected', 'error');
            return;
        }
        
        try {
            const settings = getSettings();
            const model = document.getElementById('model-select').value;
            const temperature = parseFloat(document.getElementById('temperature').value);
            const messageIdToRegenerate = selectedMessageId;
            
            console.log('Regenerating message:', { messageIdToRegenerate, conversationId, agentName });
            
            closeMessageActionsDialog();
            showToast('Regenerating message...', 'info');
            
            // Show streaming element with typing dots
            const streamingEl = document.getElementById('streaming-message');
            const streamingContent = document.getElementById('streaming-content');
            streamingContent.innerHTML = `<div id="typing-dots" class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>`;
            streamingEl.className = 'message-card assistant-message';
            streamingEl.classList.remove('hidden');
            setGeneratingState(true);
            scrollToBottom(true);  // Force scroll when regenerating
            
            await editConversation(window.currentWif, {
                conversation_id: conversationId,
                agent: agentName,
                folder_name: settings.folderName || '',
                message_id: messageIdToRegenerate,
                action: 'regenerate_message',
                model_name: model,
                temperature: temperature
            });
            
            // Connect WebSocket for streaming response
            connectWebSocket();
            
        } catch (e) {
            showToast('Failed to regenerate: ' + e.message, 'error');
            setGeneratingState(false);
            document.getElementById('streaming-message').classList.add('hidden');
        }
    };
    
    window.deleteMessage = async function() {
        if (!selectedMessageId) {
            showToast('No message selected', 'error');
            return;
        }
        
        if (!confirm('Delete this message and all messages after it?')) return;
        
        try {
            const settings = getSettings();
            const messageIdToDelete = selectedMessageId;
            
            console.log('Deleting message:', { messageIdToDelete, conversationId, agentName });
            
            closeMessageActionsDialog();
            
            await editConversation(window.currentWif, {
                conversation_id: conversationId,
                agent: agentName,
                folder_name: settings.folderName || '',
                message_id: messageIdToDelete,
                action: 'delete_message'
            });
            
            showToast('Message deleted', 'success');
            await loadConversation();
            
        } catch (e) {
            showToast('Failed to delete: ' + e.message, 'error');
        }
    };
    
    window.showMoveToFolderDialog = async function() {
        toggleConversationMenu();
        
        // Load folders
        try {
            const foldersData = await getFolders(agentName);
            const select = document.getElementById('move-folder-select');
            select.innerHTML = '';
            
            const folders = foldersData.folders || [];
            folders.forEach(folder => {
                const option = document.createElement('option');
                option.value = folder;
                option.textContent = folder;
                select.appendChild(option);
            });
            
            if (folders.length === 0) {
                select.innerHTML = '<option value="">No folders available</option>';
            }
        } catch (e) {
            console.error('Failed to load folders:', e);
        }
        
        document.getElementById('move-folder-dialog').classList.remove('hidden');
    };
    
    window.closeMoveToFolderDialog = function() {
        document.getElementById('move-folder-dialog').classList.add('hidden');
    };
    
    window.moveConversationToFolder = async function() {
        if (!conversationId) {
            showToast('No conversation to move', 'error');
            return;
        }
        
        const targetFolder = document.getElementById('move-folder-select').value;
        if (!targetFolder) {
            showToast('Please select a folder', 'error');
            return;
        }
        
        try {
            const settings = getSettings();
            await moveToFolder(window.currentWif, {
                agent: agentName,
                folder_name: settings.folderName,
                conversation_id: conversationId,
                folder: targetFolder
            });
            showToast('Conversation moved to ' + targetFolder, 'success');
            closeMoveToFolderDialog();
            // Navigate back to conversations list
            window.location.href = `/agent/${encodeURIComponent(agentName)}/conversations`;
        } catch (e) {
            showToast('Failed to move: ' + e.message, 'error');
        }
    };
    
    function updateToolsList(enabledTools) {
        const container = document.getElementById('tools-list');
        // Show all available tools from agent, check only those in enabledTools
        const allTools = agentData?.agent?.tools || [];
        if (allTools.length > 0) {
            container.innerHTML = allTools.map(tool => {
                const isEnabled = enabledTools.includes(tool);
                return `
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" value="${tool}" ${isEnabled ? 'checked' : ''} class="w-4 h-4 rounded">
                        <span class="text-sm">${tool}</span>
                    </label>
                `;
            }).join('');
        } else {
            container.innerHTML = '<span class="text-slate-500 text-sm">No tools available</span>';
        }
    }
    
    function updateRolesList(enabledRoles) {
        const container = document.getElementById('roles-list');
        // Show all available roles from agent, check only those in enabledRoles
        const allRoles = agentData?.agent?.roles || [];
        // Convert enabledRoles to array of role names for comparison
        const enabledRoleNames = enabledRoles.map(r => typeof r === 'string' ? r : (r.role_name || r.name || ''));
        
        if (allRoles.length > 0) {
            container.innerHTML = allRoles.map(role => {
                const roleName = typeof role === 'string' ? role : (role.role_name || role.name || 'Unknown');
                const isEnabled = enabledRoleNames.includes(roleName);
                return `
                    <label class="flex items-center gap-2 cursor-pointer">
                        <input type="checkbox" value="${roleName}" ${isEnabled ? 'checked' : ''} class="w-4 h-4 rounded">
                        <span class="text-sm">${roleName}</span>
                    </label>
                `;
            }).join('');
        } else {
            container.innerHTML = '<span class="text-slate-500 text-sm">No roles available</span>';
        }
    }
    
    // File handling
    window.handleFileSelect = async function(event) {
        const files = event.target.files;
        if (!files.length) return;
        
        if (!window.currentWif) {
            showToast('Please unlock your WIF key first', 'error');
            return;
        }
        
        for (const file of files) {
            try {
                showToast(`Uploading ${file.name}...`, 'info');
                
                // Upload file
                const uploadResult = await uploadFile(file);
                
                if (uploadResult.file_id) {
                    // Stage file
                    const stageData = {
                        agent: agentName,
                        conversationId: conversationId,
                        fileName: file.name,
                        fileId: uploadResult.file_id
                    };
                    
                    await stageFile(window.currentWif, stageData);
                    
                    stagedFiles.push({ fileName: file.name, fileId: uploadResult.file_id });
                    updateStagedFilesDisplay();
                    showToast(`${file.name} staged`, 'success');
                }
            } catch (e) {
                console.error('Failed to upload file:', e);
                showToast(`Failed to upload ${file.name}`, 'error');
            }
        }
        
        event.target.value = '';
    };
    
    function updateStagedFilesDisplay() {
        const container = document.getElementById('staged-files');
        const list = document.getElementById('staged-files-list');
        
        if (stagedFiles.length > 0) {
            container.classList.remove('hidden');
            list.innerHTML = stagedFiles.map((file, index) => `
                <div class="flex items-center gap-2 bg-slate-700 rounded-lg px-3 py-1">
                    <span class="text-sm">${file.fileName || file}</span>
                    <button onclick="removeStagedFileAt(${index})" class="text-slate-400 hover:text-red-400">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"/>
                        </svg>
                    </button>
                </div>
            `).join('');
        } else {
            container.classList.add('hidden');
        }
    }
    
    window.removeStagedFileAt = async function(index) {
        const file = stagedFiles[index];
        
        try {
            await removeStagedFile(window.currentWif, {
                agent: agentName,
                conversationId: conversationId,
                fileName: file.fileName || file
            });
            
            stagedFiles.splice(index, 1);
            updateStagedFilesDisplay();
        } catch (e) {
            console.error('Failed to remove staged file:', e);
            showToast('Failed to remove file', 'error');
        }
    };
    
    // WebSocket for streaming
    let streamingParts = [];
    let wsSubscribedTo = '';
    
    function connectWebSocket() {
        if (!conversationId) {
            console.log('WebSocket: No conversation ID, skipping connection');
            return;
        }
        
        const settings = getSettings();
        const wsUrl = `ws://${settings.serverAddress}:${settings.websocketPort}`;
        
        console.log('WebSocket: Connecting to', wsUrl, 'for conversation', conversationId);
        
        // If already connected and subscribed to same conversation, skip
        if (ws && ws.readyState === WebSocket.OPEN && wsSubscribedTo === conversationId) {
            console.log('WebSocket: Already connected and subscribed');
            return;
        }
        
        // Close existing connection if any
        if (ws) {
            ws.close();
            ws = null;
        }
        
        try {
            ws = new WebSocket(wsUrl);
            
            ws.onopen = () => {
                console.log('WebSocket: Connected, subscribing to', conversationId);
                ws.send(`subscribe:${conversationId}`);
                wsSubscribedTo = conversationId;
            };
            
            ws.onmessage = (event) => {
                console.log('WebSocket: Received message:', event.data.substring(0, 200));
                try {
                    const data = JSON.parse(event.data);
                    
                    // Check if this message is for our conversation
                    if (data.channel === conversationId) {
                        handleStreamingMessage(data);
                    } else {
                        console.log('WebSocket: Message for different channel:', data.channel, 'vs', conversationId);
                    }
                } catch (e) {
                    console.error('WebSocket: Failed to parse message:', e);
                }
            };
            
            ws.onerror = (error) => {
                console.error('WebSocket: Error:', error);
            };
            
            ws.onclose = (event) => {
                console.log('WebSocket: Closed, code:', event.code, 'reason:', event.reason);
                wsSubscribedTo = '';
                // Don't auto-reconnect, let the next message trigger it
            };
        } catch (e) {
            console.error('WebSocket: Failed to connect:', e);
        }
    }
    
    function handleStreamingMessage(data) {
        console.log('handleStreamingMessage:', data);
        const streamingEl = document.getElementById('streaming-message');
        const senderEl = document.getElementById('streaming-sender');
        const contentEl = document.getElementById('streaming-content');
        const avatarEl = document.getElementById('streaming-avatar');
        const typingDots = document.getElementById('typing-dots');
        const list = document.getElementById('messages-list');
        const noMessages = document.getElementById('no-messages');
        
        // Check for end of message
        if (data.message === '<|end of message|>') {
            console.log('WebSocket: End of message received');
            streamingEl.classList.add('hidden');
            streamingEl.className = 'message-card assistant-message hidden'; // Reset class
            // Reset content to typing dots for next time
            contentEl.innerHTML = `<div id="typing-dots" class="typing-dots">
                <span></span>
                <span></span>
                <span></span>
            </div>`;
            streamingParts = [];
            setGeneratingState(false);
            // Reload conversation to get the final message and trigger auto-play
            loadConversationWithAutoPlay();
            return;
        }
        
        // Update sender and avatar
        const sender = data.sender || 'Assistant';
        senderEl.textContent = sender;
        avatarEl.textContent = sender.substring(0, 2).toUpperCase();
        
        // Update streaming message style based on sender
        const senderLower = sender.toLowerCase();
        const userName = document.getElementById('sender-name')?.value || '';
        const isCurrentUser = senderLower === userName.toLowerCase();
        
        if (isCurrentUser) {
            streamingEl.className = 'message-card user-message';
        } else {
            streamingEl.className = 'message-card assistant-message';
        }
        
        // Update content - render parts if available, otherwise use message
        let hasContent = false;
        if (data.parts && data.parts.length > 0) {
            streamingParts = data.parts;
            let html = '';
            data.parts.forEach(part => {
                html += renderMessagePart(part, true); // isStreaming = true
                // Check if part has actual visible content (not just empty or thinking header)
                const content = part.content || '';
                if (content.trim().length > 0) {
                    hasContent = true;
                }
            });
            contentEl.innerHTML = html;
            
            // Highlight code blocks
            contentEl.querySelectorAll('pre code').forEach(block => {
                hljs.highlightElement(block);
            });
            
            // Render mermaid diagrams
            contentEl.querySelectorAll('.mermaid-diagram').forEach(async (el, idx) => {
                const code = el.dataset.code;
                const id = `stream-mermaid-${Date.now()}-${idx}`;
                try {
                    const { svg } = await mermaid.render(id, code);
                    el.innerHTML = svg;
                } catch (e) {
                    el.innerHTML = `<pre class="text-red-400">Mermaid error: ${e.message}</pre>`;
                }
            });
        } else if (data.message && data.message.trim().length > 0) {
            hasContent = true;
            // Process thinking tags in streaming message - show expanded during streaming
            const processedContent = processThinkingTags(data.message, true);
            if (processedContent !== data.message) {
                const parts = processedContent.split(/(<div class="thinking-block[\s\S]*?<\/div>\s*<\/div>)/);
                contentEl.innerHTML = `<div class="markdown-content">${parts.map(p => {
                    if (p.startsWith('<div class="thinking-block')) {
                        return p;
                    }
                    return marked.parse(p);
                }).join('')}</div>`;
            } else {
                contentEl.innerHTML = `<div class="markdown-content">${marked.parse(data.message)}</div>`;
            }
        }
        
        // Only show streaming content (hide typing dots) if there's actual content
        if (hasContent) {
            // typingDots may be null if content was already replaced
            if (typingDots) {
                typingDots.classList.add('hidden');
            }
            noMessages.classList.add('hidden');
            list.classList.remove('hidden');
            streamingEl.classList.remove('hidden');
        }
        
        // Always scroll to bottom when streaming content updates
        scrollToBottom();
    }
    
    function updateSidebarAgentInfo() {
        const settings = getSettings();
        const agentInfo = document.getElementById('agent-info');
        const agentAvatar = document.getElementById('agent-avatar');
        const agentNameDisplay = document.getElementById('agent-name-display');
        const agentDescDisplay = document.getElementById('agent-description-display');
        
        agentInfo.classList.remove('hidden');
        agentNameDisplay.textContent = agentName;
        agentDescDisplay.textContent = localStorage.getItem('serendipity_agent_description') || '';
        
        const profileImage = localStorage.getItem('serendipity_agent_profile_image');
        if (profileImage) {
            const imgUrl = profileImage
                .replace('<serverhost>', settings.serverAddress)
                .replace('<serverport>', settings.serverPort);
            agentAvatar.src = imgUrl;
        }
    }
    
    // Voice recording functions
    window.toggleRecording = async function() {
        if (isRecording) {
            stopRecording();
        } else {
            await startRecording();
        }
    };
    
    async function startRecording() {
        try {
            const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
            mediaRecorder = new MediaRecorder(stream);
            audioChunks = [];
            
            mediaRecorder.ondataavailable = (event) => {
                if (event.data.size > 0) {
                    audioChunks.push(event.data);
                }
            };
            
            mediaRecorder.onstop = async () => {
                const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                stream.getTracks().forEach(track => track.stop());
                await transcribeRecording(audioBlob);
            };
            
            mediaRecorder.start();
            isRecording = true;
            updateRecordingUI(true);
            showToast('Recording...', 'info');
            
        } catch (e) {
            console.error('Failed to start recording:', e);
            showToast('Failed to access microphone: ' + e.message, 'error');
        }
    }
    
    function stopRecording() {
        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
            mediaRecorder.stop();
            isRecording = false;
            updateRecordingUI(false);
        }
    }
    
    function updateRecordingUI(recording) {
        const micBtn = document.getElementById('mic-btn');
        const micIcon = document.getElementById('mic-icon');
        const micRecordingIcon = document.getElementById('mic-recording-icon');
        
        if (recording) {
            micBtn.classList.add('bg-red-600', 'border-red-500');
            micBtn.classList.remove('bg-slate-700', 'border-slate-600');
            micIcon.classList.add('hidden');
            micRecordingIcon.classList.remove('hidden');
        } else {
            micBtn.classList.remove('bg-red-600', 'border-red-500');
            micBtn.classList.add('bg-slate-700', 'border-slate-600');
            micIcon.classList.remove('hidden');
            micRecordingIcon.classList.add('hidden');
        }
    }
    
    async function transcribeRecording(audioBlob) {
        try {
            showToast('Transcribing...', 'info');
            
            const result = await transcribeAudio(audioBlob);
            
            if (result.text) {
                const input = document.getElementById('message-input');
                // Append to existing text with a space if needed
                if (input.value && !input.value.endsWith(' ')) {
                    input.value += ' ';
                }
                input.value += result.text;
                
                // Trigger resize
                input.dispatchEvent(new Event('input'));
                
                showToast('Transcription complete', 'success');
                
                // Auto-send if enabled
                const autoSend = localStorage.getItem('serendipity_auto_send') === 'true';
                if (autoSend && input.value.trim()) {
                    sendMessage();
                }
            } else {
                showToast('No speech detected', 'info');
            }
            
        } catch (e) {
            console.error('Transcription failed:', e);
            showToast('Transcription failed: ' + e.message, 'error');
        }
    }
    
    // Collapsible panel functions
    window.togglePanel = function(panelId) {
        const panel = document.getElementById(panelId);
        const icon = document.getElementById(panelId + '-icon');
        
        if (panel.classList.contains('hidden')) {
            panel.classList.remove('hidden');
            icon.classList.add('rotate-180');
            
            // Auto-load content when opening
            if (panelId === 'todo-panel') loadTodoList();
            else if (panelId === 'wishlist-panel') loadWishlist();
            else if (panelId === 'variables-panel') loadVariables();
            else if (panelId === 'workspace-panel') loadWorkspace();
            else if (panelId === 'system-message-panel') loadSystemMessage();
        } else {
            panel.classList.add('hidden');
            icon.classList.remove('rotate-180');
        }
    };
    
    function loadSystemMessage() {
        const textarea = document.getElementById('system-message-edit');
        if (agentData?.agent?.system_message) {
            textarea.value = agentData.agent.system_message;
        }
    }
    
    window.saveSystemMessage = async function() {
        showToast('System message editing requires EditAgent API - save via Edit Agent page', 'info');
    };
    
    window.loadTodoList = async function() {
        const container = document.getElementById('todo-list');
        container.innerHTML = '<span class="text-slate-500 text-sm">Loading...</span>';
        
        try {
            const data = await getTodo(agentName);
            console.log('Todo data:', data);
            
            // Handle various response formats
            let todos = [];
            if (Array.isArray(data)) {
                todos = data;
            } else if (Array.isArray(data.todo)) {
                todos = data.todo;
            } else if (Array.isArray(data.todos)) {
                todos = data.todos;
            } else if (typeof data.todo === 'string') {
                // Single string todo
                todos = data.todo ? [data.todo] : [];
            } else if (typeof data === 'object' && data.todo) {
                // Object format - display as text
                todos = [JSON.stringify(data.todo)];
            }
            
            if (todos.length === 0) {
                container.innerHTML = '<span class="text-slate-500 text-sm">No todo items</span>';
                return;
            }
            
            container.innerHTML = todos.map(item => {
                const text = typeof item === 'string' ? item : (item.text || item.content || item.task || JSON.stringify(item));
                const done = typeof item === 'object' && (item.done || item.completed);
                return `
                    <div class="flex items-start gap-2 p-2 bg-slate-700/50 rounded text-sm ${done ? 'opacity-50' : ''}">
                        <span class="${done ? 'line-through' : ''}">${escapeHtml(text)}</span>
                    </div>
                `;
            }).join('');
        } catch (e) {
            console.error('Failed to load todo:', e);
            container.innerHTML = '<span class="text-red-400 text-sm">Failed to load</span>';
        }
    };
    
    window.loadWishlist = async function() {
        const container = document.getElementById('wishlist-list');
        container.innerHTML = '<span class="text-slate-500 text-sm">Loading...</span>';
        
        try {
            const data = await getWishlist(agentName);
            const items = data.wishlist || [];
            
            if (items.length === 0) {
                container.innerHTML = '<span class="text-slate-500 text-sm">No wishlist items</span>';
                return;
            }
            
            container.innerHTML = items.map(item => {
                const text = typeof item === 'string' ? item : (item.text || item.content || JSON.stringify(item));
                return `
                    <div class="p-2 bg-slate-700/50 rounded text-sm">
                        ${escapeHtml(text)}
                    </div>
                `;
            }).join('');
        } catch (e) {
            console.error('Failed to load wishlist:', e);
            container.innerHTML = '<span class="text-red-400 text-sm">Failed to load</span>';
        }
    };
    
    window.loadVariables = async function() {
        const container = document.getElementById('variables-list');
        container.innerHTML = '<span class="text-slate-500 text-sm">Loading...</span>';
        
        try {
            const data = await getVariables(agentName);
            const vars = data.variables || {};
            const entries = Object.entries(vars);
            
            if (entries.length === 0) {
                container.innerHTML = '<span class="text-slate-500 text-sm">No variables</span>';
                return;
            }
            
            container.innerHTML = entries.map(([key, value]) => {
                const valueStr = typeof value === 'object' ? JSON.stringify(value) : String(value);
                return `
                    <div class="p-2 bg-slate-700/50 rounded">
                        <span class="text-indigo-400">${escapeHtml(key)}</span>: 
                        <span class="text-slate-300">${escapeHtml(valueStr.substring(0, 100))}${valueStr.length > 100 ? '...' : ''}</span>
                    </div>
                `;
            }).join('');
        } catch (e) {
            console.error('Failed to load variables:', e);
            container.innerHTML = '<span class="text-red-400 text-sm">Failed to load</span>';
        }
    };
    
    window.loadWorkspace = async function() {
        const container = document.getElementById('workspace-tree');
        container.innerHTML = '<span class="text-slate-500 text-sm">Loading...</span>';
        
        try {
            const data = await getWorkspace(agentName);
            const files = data.workspace || data.files || [];
            
            if (files.length === 0) {
                container.innerHTML = '<span class="text-slate-500 text-sm">Workspace is empty</span>';
                return;
            }
            
            container.innerHTML = renderFileTree(files);
        } catch (e) {
            console.error('Failed to load workspace:', e);
            container.innerHTML = '<span class="text-red-400 text-sm">Failed to load</span>';
        }
    };
    
    function renderFileTree(items, indent = 0) {
        if (!Array.isArray(items)) {
            // If it's an object, convert to array format
            if (typeof items === 'object') {
                items = Object.entries(items).map(([name, content]) => ({
                    name,
                    type: typeof content === 'object' && content !== null ? 'folder' : 'file',
                    children: typeof content === 'object' && content !== null ? content : null
                }));
            } else {
                return `<span class="text-slate-500 text-sm">Invalid workspace format</span>`;
            }
        }
        
        return items.map(item => {
            const name = item.name || item;
            const isFolder = item.type === 'folder' || item.type === 'directory' || item.children;
            const icon = isFolder ? 'üìÅ' : 'üìÑ';
            const paddingLeft = indent * 16;
            
            let html = `
                <div class="py-1 hover:bg-slate-700/50 rounded px-2 cursor-default" style="padding-left: ${paddingLeft}px">
                    <span>${icon}</span>
                    <span class="ml-1">${escapeHtml(name)}</span>
                </div>
            `;
            
            if (isFolder && item.children) {
                html += renderFileTree(item.children, indent + 1);
            }
            
            return html;
        }).join('');
    }
    
    function updateOpenFilesList() {
        const container = document.getElementById('open-files-list');
        
        if (stagedFiles.length === 0) {
            container.innerHTML = '<span class="text-slate-500 text-sm">No files in context</span>';
            return;
        }
        
        container.innerHTML = stagedFiles.map((file, idx) => `
            <div class="flex items-center justify-between p-2 bg-slate-700/50 rounded text-sm">
                <span class="truncate flex-1">üìÑ ${escapeHtml(file.name || file.filename || 'File ' + (idx + 1))}</span>
                <button onclick="removeOpenFile(${idx})" class="text-red-400 hover:text-red-300 ml-2">√ó</button>
            </div>
        `).join('');
    }
    
    window.removeOpenFile = function(idx) {
        if (stagedFiles[idx]) {
            removeStagedFile(stagedFiles[idx].id);
            stagedFiles.splice(idx, 1);
            updateOpenFilesList();
            updateStagedFilesDisplay();
        }
    };
</script>
{% endblock %}
